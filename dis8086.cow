#
# Copyright (c) 2020 Brian Callahan <bcallah@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

# 8086 disassembler

include "stdcow.coh";
include "argv.coh";
include "strings.coh";

var InputFile: FCB;

var count: uint16 := 15;
var offset: uint16 := 0;
var loadaddr: uint16 := 0x100;

var len: uint32;
var pc: uint16;
var byte: uint8;

var strbuf: uint8[32];

sub UnimplementedOp() is
	print("Unimplemented opcode: ");
	print_hex_i8(byte);
	print_nl();

	ExitWithError();
end sub;

sub IllegalOp() is
	print("Illegal opcode: ");
	print_hex_i8(byte);
	print_nl();

	ExitWithError();
end sub;

sub AToH(buffer: [uint8]): (result: uint16) is
	var c: uint8 := [buffer];

	result := 0;

	loop
		if c >= '0' and c <= '9' then
			c := c - '0';
		elseif c >= 'A' and c <= 'F' then
			c := c - 'A' + 10;
		elseif c >= 'a' and c <= 'f' then
			c := c - 'a' + 10;
		else
			break;
		end if;

		result := result * 16 + (c as uint16);
		buffer := buffer + 1;
		c := [buffer];
	end loop;
end sub;

sub NextChar(): (ret: uint8) is
	ret := FCBGetChar(&InputFile);
	pc := pc + 1;
end sub;

sub GetReg(input: uint8, size: uint8): (output: [uint8]) is
	case input is
		when 0:
			if size == 16 then
				output := "ax";
			else
				output := "al";
			end if;
		when 1:
			if size == 16 then
				output := "cx";
			else
				output := "cl";
			end if;
		when 2:
			if size == 16 then
				output := "dx";
			else
				output := "dl";
			end if;
		when 3:
			if size == 16 then
				output := "bx";
			else
				output := "bl";
			end if;
		when 4:
			if size == 16 then
				output := "sp";
			else
				output := "ah";
			end if;
		when 5:
			if size == 16 then
				output := "bp";
			else
				output := "ch";
			end if;
		when 6:
			if size == 16 then
				output := "si";
			else
				output := "dh";
			end if;
		when 7:
			if size == 16 then
				output := "di";
			else
				output := "bh";
			end if;
	end case;
end sub;

sub OneByte(inst: [uint8], reg: [uint8]) is
	print_hex_i8(byte);
	print("\t\t");
	print(inst);
	if (reg != 0 as [uint8]) then
		print("\t");
		print(reg);
	end if;
end sub;

sub TwoByte(inst: [uint8], reg: [uint8]) is
	var t: uint8 := NextChar();

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t);
	print("\t\t");
	print(inst);
	print("\t");
	if (reg != 0) then
		print(reg);
		print(", ");
	end if;
	print("0x");
	print_hex_i8(t);
end sub;

sub ThreeByte(inst: [uint8], reg: [uint8]) is
	var t1: uint8 := NextChar();
	var t2: uint8 := NextChar();

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
	print(" ");
	print_hex_i8(t2);
	print("\t");
	print(inst);
	print("\t");
	if reg != (0 as [uint8]) then
		print(reg);
		print(", ");
	end if;
	print("0x");
	print_hex_i8(t2);
	print_hex_i8(t1);
end sub;

sub Jump8(type: [uint8]) is
	var t1: uint8 := NextChar();
	var final: uint8 := (pc as uint8) + t1 + 1;

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
	print("\t\t");
	print(type);
	print("\t0x");
	print_hex_i8(final);
end sub;

sub Call16() is
	var t1: uint8 := NextChar();
	var t2: uint8 := NextChar();
	var combo: int16 := ((t2 as int16) << 8) + (t1 as int16);
	var final: uint16;

	final := pc + (combo as uint16) + 1;

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
	print(" ");
	print_hex_i8(t2);
	print("\tcall\t0x");
	print_hex_i16(final);
end sub;

sub Rm(reg: uint8, size: uint8) is
	var mod: uint8 := reg >> 6;
	var rm8: uint8 := reg & 7;
	var output: [uint8];
	var c: uint8;
	var i: uint8 := 0;

	case mod is
		when 0x00:
			if rm8 == 0x06 then
				var t1: uint8 := NextChar();
				var t2: uint8 := NextChar();
				var combo: uint16 := ((t2 as uint16) << 8) + (t1 as uint16);

				print("+0x");
				print_hex_i16(combo);
			end if;
		when 0x01:
			var s1: uint8 := NextChar();

			if s1 < 0 then
				s1 := -s1;
				print("-");
			else
				print("+");
			end if;

			print("0x");
			print_hex_i16((s1 as uint16));
		when 0x02:
			var r1: uint8 := NextChar();
			var r2: uint8 := NextChar();
			var total: uint16 := ((r2 as uint16) << 8) + (r1 as uint16);

			print("+0x");
			print_hex_i16(total);
		when 0x03:
			if size == 8 then
				output := GetReg(rm8, 8);
			elseif size == 16 then
				output := GetReg(rm8, 16);
			end if;
	end case;

	# XXX: finish this part
	if mod != 0x03 then
		case rm8 is
			when 0x00:
				output := "[bx + si]";
			when 0x01:
				output := "[bx + si]";
			when 0x02:
				output := "[bx + si]";
			when 0x03:
				output := "[bx + si]";
			when 0x04:
				output := "[bx + si]";
			when 0x05:
				output := "[bx + si]";
			when 0x06:
				output := "[bx + si]";
			when 0x07:
				output := "[bx + si]";
		end case;
	end if;

	MemZero((&strbuf as [uint8]), 32);
	c := [output];
	while c != 0 loop
		strbuf[i] := c;
		i := i + 1;
		output := output + 1;
		c := [output];
	end loop;
end sub;

sub Combine(second: [uint8]) is
	var len: intptr := StrLen((&strbuf as [uint8]));
	var c: uint8;

	c := [second];
	while len < 31 loop
		strbuf[(len as uint8)] := c;
		len := len + 1;
		second := second + 1;
		c := [second];
	end loop;
end sub;

sub Off16(input: uint8, type: uint8): (output: [uint8]) is
	var t1: uint8 := NextChar();
	var t2: uint8 := NextChar();
	var combo: uint16 := ((t2 as uint16) << 8) + (t1 as uint16);
	var pe: [uint8];
	var buffer: uint8[11];

	print_hex_i8(input);
	print(" ");
	print_hex_i8(t1);
	print(" ");
	print_hex_i8(t2);

	MemZero((&strbuf as [uint8]), 32);
	if type == 0 then
		Combine("byte ptr [0x");
	else
		Combine("word ptr [0x");
	end if;
	pe := IToA((combo as int32), 16, (&buffer[0] as [uint8]));
	Combine(&buffer[0]);
	Combine("]");

	output := &strbuf[0];
end sub;

sub Rm16I8(): (out: uint8) is
	var reg: uint8;
	var byte2: uint8;
	var output: [uint8];
	var negative: uint8 := 0;
	var pe: [uint8];
	var buffer: uint8[11];

	out := byte;
	Rm(out, 16);

	Combine(", ");
	byte := NextChar();
	if negative == 1 then
		Combine("-");
	end if;
	Combine("0x");
	pe := IToA((byte as int32), 16, (&buffer[0] as [uint8]));
	Combine(&buffer[0]);
end sub;

sub Rm16R16(): (byte: uint8) is
	var reg: uint8;
	var output: [uint8];

	byte := NextChar();
	reg := byte;

	Rm(reg, 16);
	reg := (reg & 0x38) >> 3;
	Combine(", ");
	Combine(GetReg(reg, 16));
end sub;

sub Arith(origin: uint8, operator: [uint8]) is
	print_hex_i8(origin);
	print(" ");
	print_hex_i8(byte);
	print("\t\t");
	print(operator);
	print("\t");
	print((&strbuf as [uint8]));
end sub;

sub Arith2(origin: uint8, origin2: uint8, operator: [uint8]) is
	print_hex_i8(origin);
	print(" ");
	print_hex_i8(origin2);
	print(" ");
	print_hex_i8(byte);
	print("\t");
	print(operator);
	print("\t");
	print((&strbuf as [uint8]));
end sub;

sub MovRm16R16() is
	var temppc: uint16 := pc;
	var t1: uint8 := NextChar();
	var reg: uint8 := (t1 & 0x38) >> 3;

	Rm(t1, 16);

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
	if pc - temppc < 3 then
		print("\t");
	end if;
	print("\tmov\t");
	print((&strbuf as [uint8]));
	print(", ");
	print(GetReg(reg, 16));
end sub;

sub MovR16Rm16() is
	var temppc: uint16 := pc;
	var t1: uint8 := NextChar();
	var reg: uint8 := (t1 & 0x38) >> 3;

	Rm(t1, 16);

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
	if pc - temppc < 3 then
		print("\t");
	end if;
	print("\tmov\t");
	print(GetReg(reg, 16));
	print(", ");
	print((&strbuf as [uint8]));
end sub;

sub MovR8Rm8() is
	var t1: uint8 := NextChar();
	var reg: uint8 := (t1 & 0x38) >> 3;

	Rm(t1, 8);

	Combine(", ");
	Combine(GetReg(reg, 8));

	print_hex_i8(byte);
	print(" ");
	print_hex_i8(t1);
end sub;

sub MovMR(reg: [uint8], imm: [uint8]) is
	print("\tmov\t");
	print(imm);
	print(", ");
	print(reg);
end sub;

sub MovRM(reg: [uint8], imm: [uint8]) is
	print("\tmov\t");
	print(reg);
	print(", ");
	print(imm);
end sub;

# Cowgol doesn't notice if you have 2+ identical strings.
# So you have lots of repetition in the binary.
# This is gross, but perhaps the best we can do for now.
sub Disassemble() is
	var opcode: uint8;

	var ax: [uint8] := "ax";
	var bx: [uint8] := "bx";
	var cx: [uint8] := "cx";
	var dx: [uint8] := "dx";
	var al: [uint8] := "al";
	var bl: [uint8] := "bl";
	var cl: [uint8] := "cl";
	var dl: [uint8] := "dl";
	var ah: [uint8] := "ah";
	var bh: [uint8] := "bh";
	var ch: [uint8] := "ch";
	var dh: [uint8] := "dh";
	var sp: [uint8] := "sp";
	var bp: [uint8] := "bp";
	var si: [uint8] := "si";
	var di: [uint8] := "di";
	var es: [uint8] := "es";
	var cs: [uint8] := "cs";
	var ss: [uint8] := "ss";
	var ds: [uint8] := "ds";

	var mov: [uint8] := "mov";
	var add: [uint8] := "add";
	var adc: [uint8] := "adc";
	var and_inst: [uint8] := "and";
	var or_inst: [uint8] := "or";
	var xor: [uint8] := "xor";
	var inc: [uint8] := "inc";
	var dec: [uint8] := "dec";
	var sbb: [uint8] := "sbb";
	var sub_inst: [uint8] := "sub";
	var cmp: [uint8] := "cmp";
	var pop: [uint8] := "pop";
	var jmp: [uint8] := "jmp";
	var push: [uint8] := "push";
	var ret: [uint8] := "ret";
	var retf: [uint8] := "retf";
	var call: [uint8] := "call";
	var xchg: [uint8] := "xchg";
	var in: [uint8] := "in";
	var out: [uint8] := "out";

	byte := FCBGetChar(&InputFile);

	print("    ");
	print_hex_i16(pc);
	print(":\t");

	case byte is
		when 0x00: UnimplementedOp();
		when 0x01: byte := Rm16R16(); Arith(0x01, add);
		when 0x02: UnimplementedOp();
		when 0x03: UnimplementedOp();
		when 0x04: TwoByte(add, al);
		when 0x05: ThreeByte(add, ax);
		when 0x06: OneByte(push, es);
		when 0x07: OneByte(pop, es);
		when 0x08: UnimplementedOp();
		when 0x09: byte := Rm16R16(); Arith(0x09, or_inst);
		when 0x0a: UnimplementedOp();
		when 0x0b: UnimplementedOp();
		when 0x0c: TwoByte(or_inst, al);
		when 0x0d: ThreeByte(or_inst, ax);
		when 0x0e: OneByte(push, cs);
		when 0x0f: OneByte(pop, cs);
		when 0x10: UnimplementedOp();
		when 0x11: UnimplementedOp();
		when 0x12: UnimplementedOp();
		when 0x13: UnimplementedOp();
		when 0x14: TwoByte(adc, al);
		when 0x15: ThreeByte(adc, ax);
		when 0x16: OneByte(push, ss);
		when 0x17: OneByte(pop, ss);
		when 0x18: UnimplementedOp();
		when 0x19: byte := Rm16R16(); Arith(0x19, sbb);
		when 0x1a: UnimplementedOp();
		when 0x1b: UnimplementedOp();
		when 0x1c: TwoByte(sbb, al);
		when 0x1d: ThreeByte(sbb, ax);
		when 0x1e: OneByte(push, ds);
		when 0x1f: OneByte(pop, ds);
		when 0x20: UnimplementedOp();
		when 0x21: UnimplementedOp();
		when 0x22: UnimplementedOp();
		when 0x23: UnimplementedOp();
		when 0x24: TwoByte(and_inst, al);
		when 0x25: ThreeByte(and_inst, ax);
		when 0x26: OneByte("es:", 0);
		when 0x27: OneByte("daa", 0);
		when 0x28: UnimplementedOp();
		when 0x29: byte := Rm16R16(); Arith(0x29, sub_inst);
		when 0x2a: UnimplementedOp();
		when 0x2b: UnimplementedOp();
		when 0x2c: TwoByte(sub_inst, al);
		when 0x2d: ThreeByte(sub_inst, ax);
		when 0x2e: OneByte("cs:", 0);
		when 0x2f: OneByte("das", 0);
		when 0x30: UnimplementedOp();
		when 0x31: byte := Rm16R16(); Arith(0x31, xor);
		when 0x32: UnimplementedOp();
		when 0x33: UnimplementedOp();
		when 0x34: TwoByte(xor, al);
		when 0x35: ThreeByte(xor, ax);
		when 0x36: OneByte("ss:", 0);
		when 0x37: OneByte("aaa", 0);
		when 0x38: UnimplementedOp();
		when 0x39: byte := Rm16R16(); Arith(0x39, cmp);
		when 0x3a: UnimplementedOp();
		when 0x3b: UnimplementedOp();
		when 0x3c: TwoByte(cmp, al);
		when 0x3d: ThreeByte(cmp, ax);
		when 0x3e: OneByte("ds:", 0);
		when 0x3f: OneByte("aas", 0);
		when 0x40: OneByte(inc, ax);
		when 0x41: OneByte(inc, cx);
		when 0x42: OneByte(inc, dx);
		when 0x43: OneByte(inc, bx);
		when 0x44: OneByte(inc, sp);
		when 0x45: OneByte(inc, bp);
		when 0x46: OneByte(inc, si);
		when 0x47: OneByte(inc, di);
		when 0x48: OneByte(dec, ax);
		when 0x49: OneByte(dec, cx);
		when 0x4a: OneByte(dec, dx);
		when 0x4b: OneByte(dec, bx);
		when 0x4c: OneByte(dec, sp);
		when 0x4d: OneByte(dec, bp);
		when 0x4e: OneByte(dec, si);
		when 0x4f: OneByte(dec, di);
		when 0x50: OneByte(push, ax);
		when 0x51: OneByte(push, cx);
		when 0x52: OneByte(push, dx);
		when 0x53: OneByte(push, bx);
		when 0x54: OneByte(push, sp);
		when 0x55: OneByte(push, bp);
		when 0x56: OneByte(push, si);
		when 0x57: OneByte(push, di);
		when 0x58: OneByte(pop, ax);
		when 0x59: OneByte(pop, cx);
		when 0x5a: OneByte(pop, dx);
		when 0x5b: OneByte(pop, bx);
		when 0x5c: OneByte(pop, sp);
		when 0x5d: OneByte(pop, bp);
		when 0x5e: OneByte(pop, si);
		when 0x5f: OneByte(pop, di);
		when 0x60: IllegalOp();
		when 0x61: IllegalOp();
		when 0x62: IllegalOp();
		when 0x63: IllegalOp();
		when 0x64: IllegalOp();
		when 0x65: IllegalOp();
		when 0x66: IllegalOp();
		when 0x67: IllegalOp();
		when 0x68: IllegalOp();
		when 0x69: IllegalOp();
		when 0x6a: IllegalOp();
		when 0x6b: IllegalOp();
		when 0x6c: IllegalOp();
		when 0x6d: IllegalOp();
		when 0x6e: IllegalOp();
		when 0x6f: IllegalOp();
		when 0x70: Jump8("jo");
		when 0x71: Jump8("jno");
		when 0x72: Jump8("jb");
		when 0x73: Jump8("jnb");
		when 0x74: Jump8("jz");
		when 0x75: Jump8("jnz");
		when 0x76: Jump8("jbe");
		when 0x77: Jump8("ja");
		when 0x78: Jump8("js");
		when 0x79: Jump8("jns");
		when 0x7a: Jump8("jpe");
		when 0x7b: Jump8("jpo");
		when 0x7c: Jump8("jl");
		when 0x7d: Jump8("jge");
		when 0x7e: Jump8("jle");
		when 0x7f: Jump8("jg");
		when 0x80: UnimplementedOp();
		when 0x81: UnimplementedOp();
		when 0x82: UnimplementedOp();
		when 0x83:
			byte := NextChar();
			opcode := (byte & 0x38) >> 3;
			case opcode is
				when 0x03:
					Arith2(0x83, Rm16I8(), sbb);
			end case;
		when 0x84: UnimplementedOp();
		when 0x85: UnimplementedOp();
		when 0x86: UnimplementedOp();
		when 0x87: byte := Rm16R16(); Arith(0x87, xchg);
		when 0x88: MovR8Rm8();
		when 0x89: MovRm16R16();
		when 0x8a: MovR8Rm8();
		when 0x8b: MovR16Rm16();
		when 0x8c: UnimplementedOp();
		when 0x8d: UnimplementedOp();
		when 0x8e: UnimplementedOp();
		when 0x8f: UnimplementedOp();
		when 0x90: OneByte("nop", 0);
		when 0x91: OneByte(xchg, "cx, ax");
		when 0x92: OneByte(xchg, "dx, ax");
		when 0x93: OneByte(xchg, "bx, ax");
		when 0x94: OneByte(xchg, "sp, ax");
		when 0x95: OneByte(xchg, "bp, ax");
		when 0x96: OneByte(xchg, "si, ax");
		when 0x97: OneByte(xchg, "di, ax");
		when 0x98: OneByte("cbw", 0);
		when 0x99: OneByte("cwd", 0);
		when 0x9a: UnimplementedOp();
		when 0x9b: OneByte("wait", 0);
		when 0x9c: OneByte("pushf", 0);
		when 0x9d: OneByte("popf", 0);
		when 0x9e: OneByte("sahf", 0);
		when 0x9f: OneByte("lahf", 0);
		when 0xa0: MovRM(al, Off16(byte, 0));
		when 0xa1: MovRM(ax, Off16(byte, 1));
		when 0xa2: MovRM(Off16(byte, 0), al);
		when 0xa3: MovRM(Off16(byte, 1), ax);
		when 0xa4: OneByte("movsb", 0);
		when 0xa5: OneByte("movsw", 0);
		when 0xa6: OneByte("cmpsb", 0);
		when 0xa7: OneByte("cmpsw", 0);
		when 0xa8: UnimplementedOp();
		when 0xa9: UnimplementedOp();
		when 0xaa: OneByte("stosb", 0);
		when 0xab: OneByte("stosw", 0);
		when 0xac: OneByte("lodsb", 0);
		when 0xad: OneByte("lodsw", 0);
		when 0xae: OneByte("scasb", 0);
		when 0xaf: OneByte("scasw", 0);
		when 0xb0: TwoByte(mov, al);
		when 0xb1: TwoByte(mov, cl);
		when 0xb2: TwoByte(mov, dl);
		when 0xb3: TwoByte(mov, bl);
		when 0xb4: TwoByte(mov, ah);
		when 0xb5: TwoByte(mov, ch);
		when 0xb6: TwoByte(mov, dh);
		when 0xb7: TwoByte(mov, bh);
		when 0xb8: ThreeByte(mov, ax);
		when 0xb9: ThreeByte(mov, cx);
		when 0xba: ThreeByte(mov, dx);
		when 0xbb: ThreeByte(mov, bx);
		when 0xbc: ThreeByte(mov, sp);
		when 0xbd: ThreeByte(mov, bp);
		when 0xbe: ThreeByte(mov, si);
		when 0xbf: ThreeByte(mov, di);
		when 0xc0: IllegalOp();
		when 0xc1: IllegalOp();
		when 0xc2: ThreeByte(ret, 0);
		when 0xc3: OneByte(ret, 0);
		when 0xc4: UnimplementedOp();
		when 0xc5: UnimplementedOp();
		when 0xc6: UnimplementedOp();
		when 0xc7: UnimplementedOp();
		when 0xc8: IllegalOp();
		when 0xc9: IllegalOp();
		when 0xca: ThreeByte(retf, 0);
		when 0xcb: OneByte(retf, 0);
		when 0xcc: OneByte("int\t3", 0);
		when 0xcd: TwoByte("int", 0);
		when 0xce: OneByte("into", 0);
		when 0xcf: OneByte("iret", 0);
		when 0xd0: UnimplementedOp();
		when 0xd1:
			byte := NextChar();
			opcode := (byte & 0x38) >> 3;
			case opcode is
				when 0x02:
					Rm(byte, 16); Arith(0xd1, "rcl");
				when 0x04:
					Rm(byte, 16); Arith(0xd1, "shl");
			end case;
			print(", 1");
		when 0xd2: UnimplementedOp();
		when 0xd3: UnimplementedOp();
		when 0xd4: TwoByte("aam", 0);
		when 0xd5: TwoByte("aad", 0);
		when 0xd6: IllegalOp();
		when 0xd7: OneByte("xlat", 0);
		when 0xd8: IllegalOp();
		when 0xd9: IllegalOp();
		when 0xda: IllegalOp();
		when 0xdb: IllegalOp();
		when 0xdc: IllegalOp();
		when 0xdd: IllegalOp();
		when 0xde: IllegalOp();
		when 0xdf: IllegalOp();
		when 0xe0: UnimplementedOp();
		when 0xe1: UnimplementedOp();
		when 0xe2: UnimplementedOp();
		when 0xe3: UnimplementedOp();
		when 0xe4: UnimplementedOp();
		when 0xe5: UnimplementedOp();
		when 0xe6: UnimplementedOp();
		when 0xe7: UnimplementedOp();
		when 0xe8: Call16();
		when 0xe9: UnimplementedOp();
		when 0xea: UnimplementedOp();
		when 0xeb: Jump8("jmp");
		when 0xec: OneByte(in, "al, dx");
		when 0xed: OneByte(in, "ax, dx");
		when 0xee: OneByte(out, "dx, al");
		when 0xef: OneByte(out, "dx, ax");
		when 0xf0: OneByte("lock", 0);
		when 0xf1: IllegalOp();
		when 0xf2: OneByte("repnz", 0);
		when 0xf3: OneByte("repz", 0);
		when 0xf4: OneByte("hlt", 0);
		when 0xf5: OneByte("cmc", 0);
		when 0xf6: UnimplementedOp();
		when 0xf7:
			byte := NextChar();
			opcode := (byte & 0x38) >> 3;
			case opcode is
				when 0x03:
					Rm(byte, 16); Arith(0xf7, "neg");
				when 0x04:
					Rm(byte, 16); Arith(0xf7, "mul");
			end case;
		when 0xf8: OneByte("clc", 0);
		when 0xf9: OneByte("stc", 0);
		when 0xfa: OneByte("cli", 0);
		when 0xfb: OneByte("sti", 0);
		when 0xfc: OneByte("cld", 0);
		when 0xfd: OneByte("std", 0);
		when 0xfe: UnimplementedOp();
		when 0xff: UnimplementedOp();
	end case;

	print("\n");
end sub;

ArgvInit();

var FileName: [uint8] := ArgvNext();
if FileName == (0 as [uint8]) then
	print("usage: dis8086 file [count] [offset] [loadaddr]\n");
	ExitWithError();
end if;

if FCBOpenIn(&InputFile, FileName) != 0 then
	print("dis8086: cannot open ");
	print(FileName);
	print("\n");
	ExitWithError();
end if;

var argp: [uint8] := ArgvNext();
if argp != (0 as [uint8]) then
	count := AToH(argp);

	argp := ArgvNext();
	if argp != (0 as [uint8]) then
		offset := AToH(argp);

		argp := ArgvNext();
		if argp != (0 as [uint8]) then
			loadaddr := AToH(argp);
		end if;
	end if;
end if;

pc := ((loadaddr + offset) as uint16);
len := FCBExt(&InputFile);

if (loadaddr + offset) > (len as uint16) then
	Exit();
end if;

# FCBSeek might not always be correct?
while (offset > 0) loop
	byte := FCBGetChar(&InputFile);
	offset := offset - 1;
end loop;

while (pc as uint32) < len and count > 0 loop
	Disassemble();
	pc := pc + 1;
	count := count - 1;
end loop;

if FCBClose(&InputFile) != 0 then
	ExitWithError();
end if;
